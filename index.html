<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Mock 3D (escala fija, sin descargas)</title>
<style>
  :root{ --ml-yellow:#fff159; --ml-blue:#3483fa; --ml-text:#333; --ml-bg:#f5f5f5;}
  *{box-sizing:border-box} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--ml-bg);color:var(--ml-text)}
  header{background:var(--ml-yellow);padding:14px 16px;position:sticky;top:0;z-index:10;display:flex;gap:12px;align-items:center}
  header .logo{width:124px;height:24px;background:#000;color:#fff;border-radius:4px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px}
  header input{flex:1;border:none;border-radius:6px;padding:10px 12px;outline:none}
  .container{max-width:980px;margin:16px auto;padding:0 12px}
  .card{background:#fff;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06);overflow:hidden}
  .grid{display:grid;grid-template-columns:1fr}
  .pad{padding:16px}
  h1{font-size:20px;margin:6px 0 8px}.price{font-size:24px;font-weight:700;margin:6px 0 12px}
  .badges{display:flex;gap:8px;margin:8px 0 12px}
  .badge{background:#eef3ff;color:#2b64d8;font-weight:600;font-size:12px;padding:6px 10px;border-radius:999px}
  .hint{font-size:12px;color:#666;margin-top:6px}
  .btns{display:flex;gap:10px;flex-wrap:wrap;margin:12px 0}
  .btn{padding:12px 14px;border:none;border-radius:10px;font-weight:700;cursor:pointer}
  .btn-primary{background:var(--ml-blue);color:#fff}.btn-secondary{background:#eef3ff;color:#2b64d8}
  .actions{display:flex;gap:10px;padding:12px;border-top:1px solid #eee;background:#fff}
  .actions .btn{flex:1}
  canvas{width:100%;height:60vh;display:block;border-radius:12px;background:#fff;touch-action:none}
  #hero{height:54vh}
  @media(min-width:880px){ .grid{grid-template-columns:1.1fr .9fr;gap:10px} #hero{height:58vh}}
</style>
</head>
<body>
<header>
  <div class="logo">ML Mock</div>
  <input placeholder="Buscar productos, marcas y m√°s‚Ä¶" aria-label="Buscar"/>
</header>

<main class="container">
  <section class="card">
    <div class="grid">
      <div class="pad">
        <div class="badges"><div class="badge">NUEVO</div><div class="badge">3D</div></div>
        <!-- ‚ÄúFoto‚Äù 3D sin controles (canvas est√°tico) -->
        <canvas id="hero" aria-label="Vista del producto"></canvas>
        <p class="hint">Imagen superior renderizada en tiempo real (sin PNG/JPG ni descargas externas).</p>
      </div>
      <div class="pad">
        <h1>Objeto demo (volumen tipo zapatilla)</h1>
        <div class="price">$ 19.999</div>
        <p>Escala fija 1:1 ‚Ä¢ Sin zoom/pan ‚Ä¢ Rotaci√≥n √∫nicamente</p>
        <div class="btns">
          <button class="btn btn-primary">Comprar ahora</button>
          <button class="btn btn-secondary" id="toggle">üëì Ver en 3D</button>
        </div>
        <ul class="hint">
          <li>El tama√±o NO cambia: zoom y pan deshabilitados a nivel de motor y eventos.</li>
        </ul>
      </div>
    </div>

    <div class="pad" id="viewerWrap" style="display:none;border-top:1px solid #eee;background:#fafafa">
      <!-- Visor interactivo: solo rotaci√≥n -->
      <canvas id="viewer" aria-label="Visor 3D interactivo (rotaci√≥n)"></canvas>
      <p class="hint">Rot√° con un dedo. Pinch, doble-tap y rueda est√°n bloqueados.</p>
    </div>

    <div class="actions">
      <button class="btn btn-secondary">Agregar al carrito</button>
      <button class="btn btn-primary">Comprar ahora</button>
    </div>
  </section>
</main>

<script>
/*
  Mini motor WebGL sin dependencias:
  - Renderiza un ‚Äúcuerpo‚Äù con proporciones 26√ó10√ó8 cm (0.26√ó0.10√ó0.08 m).
  - Luz b√°sica y material PBR simplificado.
  - Bloquea zoom/pan: no hay matrices de zoom, no hay c√°mara con rueda; s√≥lo rotaci√≥n sobre Y/X.
  - Eventos de pinch/wheel/gesture cancelados.
*/

// ---------- utilidades ----------
function mat4Identity(){return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]}
function mat4Multiply(a,b){
  const o=new Array(16);
  for(let r=0;r<4;r++)for(let c=0;c<4;c++){
    o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];
  } return o;
}
function mat4Perspective(fovy,aspect,near,far){
  const f=1/Math.tan(fovy/2), nf=1/(near-far);
  return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0];
}
function mat4Translate(m,[x,y,z]){const t=mat4Identity(); t[12]=x;t[13]=y;t[14]=z; return mat4Multiply(m,t);}
function mat4RotateX(m,a){const c=Math.cos(a),s=Math.sin(a); const r=[1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]; return mat4Multiply(m,r);}
function mat4RotateY(m,a){const c=Math.cos(a),s=Math.sin(a); const r=[c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]; return mat4Multiply(m,r);}
function vec3Normalize([x,y,z]){const l=Math.hypot(x,y,z)||1; return [x/l,y/l,z/l]}

// ---------- geometr√≠a: caja ‚Äúzapatilla‚Äù 26√ó10√ó8 cm ----------
function makeBoxGeometry(L=0.26,W=0.10,H=0.08){
  const sx=L/2, sy=W/2, sz=H/2;
  const positions=[
    // +X
    sx,-sy,-sz,  sx, sy,-sz,  sx, sy, sz,  sx,-sy, sz,
    // -X
    -sx,-sy, sz, -sx, sy, sz, -sx, sy,-sz, -sx,-sy,-sz,
    // +Y
    -sx, sy,-sz,  sx, sy,-sz,  sx, sy, sz, -sx, sy, sz,
    // -Y
    -sx,-sy, sz,  sx,-sy, sz,  sx,-sy,-sz, -sx,-sy,-sz,
    // +Z
    -sx,-sy, sz,  sx,-sy, sz,  sx, sy, sz, -sx, sy, sz,
    // -Z
    -sx, sy,-sz,  sx, sy,-sz,  sx,-sy,-sz, -sx,-sy,-sz
  ];
  const normals=[
    // +X
    1,0,0, 1,0,0, 1,0,0, 1,0,0,
    // -X
    -1,0,0,-1,0,0,-1,0,0,-1,0,0,
    // +Y
    0,1,0,0,1,0,0,1,0,0,1,0,
    // -Y
    0,-1,0,0,-1,0,0,-1,0,0,-1,0,
    // +Z
    0,0,1,0,0,1,0,0,1,0,0,1,
    // -Z
    0,0,-1,0,0,-1,0,0,-1,0,0,-1
  ];
  const indices=[];
  for(let i=0;i<6;i++){ const b=i*4; indices.push(b,b+1,b+2, b,b+2,b+3); }
  return {positions:new Float32Array(positions), normals:new Float32Array(normals), indices:new Uint16Array(indices)};
}

// ---------- render ----------
function startViewer(canvas, allowRotate=true){
  const gl=canvas.getContext('webgl',{antialias:true,alpha:false});
  if(!gl){ canvas.insertAdjacentHTML('afterend','<div style="color:#b00">Este dispositivo no soporta WebGL</div>'); return;}
  const vs=`
  attribute vec3 position;
  attribute vec3 normal;
  uniform mat4 uMVP;
  uniform mat4 uModel;
  varying vec3 vN, vP;
  void main(){
    vN = mat3(uModel) * normal;
    vP = (uModel * vec4(position,1.0)).xyz;
    gl_Position = uMVP * vec4(position,1.0);
  }`;
  const fs=`
  precision mediump float;
  varying vec3 vN, vP;
  uniform vec3 uCam, uColor;
  void main(){
    vec3 N = normalize(vN);
    vec3 L = normalize(vec3(0.4,0.8,0.6));
    vec3 V = normalize(uCam - vP);
    vec3 H = normalize(L+V);
    float diff = max(dot(N,L), 0.0);
    float spec = pow(max(dot(N,H),0.0), 32.0);
    vec3 base = uColor * (0.15 + 0.85*diff) + vec3(0.25)*spec;
    gl_FragColor = vec4(base,1.0);
  }`;
  function compile(type,src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s;}
  const prog=gl.createProgram(); gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs)); gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) throw gl.getProgramInfoLog(prog);
  gl.useProgram(prog);

  const {positions,normals,indices}=makeBoxGeometry();
  function buf(arr,loc,size,type){ const b=gl.createBuffer(); gl.bindBuffer(type,b); gl.bufferData(type,arr,gl.STATIC_DRAW); if(type===gl.ARRAY_BUFFER){ gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,size,gl.FLOAT,false,0,0);} return b;}
  const locPos=gl.getAttribLocation(prog,'position'), locNor=gl.getAttribLocation(prog,'normal');
  buf(positions, locPos, 3, gl.ARRAY_BUFFER);
  buf(normals,   locNor, 3, gl.ARRAY_BUFFER);
  const ibo=buf(indices, 0, 0, gl.ELEMENT_ARRAY_BUFFER);

  const uMVP=gl.getUniformLocation(prog,'uMVP');
  const uModel=gl.getUniformLocation(prog,'uModel');
  const uCam=gl.getUniformLocation(prog,'uCam');
  const uColor=gl.getUniformLocation(prog,'uColor');

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = canvas.clientWidth|0, h = canvas.clientHeight|0;
    canvas.width = w*dpr; canvas.height = h*dpr;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  resize(); window.addEventListener('resize', resize);

  let rotX = 0.6, rotY = 0.6; // orientaci√≥n inicial
  const radius = 0.7;         // distancia de c√°mara fija (TAMA√ëO FIJO)
  const fov = 45 * Math.PI/180; // FOV fijo

  // ---- GESTOS: rotaci√≥n solamente ----
  let dragging=false, lastX=0,lastY=0;
  canvas.addEventListener('touchstart',e=>{ if(e.touches.length===1){ dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; } e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchmove',e=>{
    if(dragging && e.touches.length===1){
      const x=e.touches[0].clientX, y=e.touches[0].clientY;
      rotY += (x-lastX)*0.01; rotX += (y-lastY)*0.01; rotX=Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
      lastX=x; lastY=y;
    }
    // BLOQUEO pinch/gestures
    if(e.touches.length>1) e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchend',()=>{dragging=false});
  canvas.addEventListener('mousedown',e=>{dragging=true; lastX=e.clientX; lastY=e.clientY; e.preventDefault();});
  canvas.addEventListener('mousemove',e=>{if(dragging){ rotY += (e.clientX-lastX)*0.01; rotX += (e.clientY-lastY)*0.01; rotX=Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX)); lastX=e.clientX; lastY=e.clientY; }});
  ['mouseup','mouseleave'].forEach(ev=>canvas.addEventListener(ev,()=>{dragging=false}));
  // BLOQUEO zoom/pan del navegador
  canvas.addEventListener('wheel', e=>e.preventDefault(), {passive:false});
  ['gesturestart','gesturechange','gestureend','dblclick'].forEach(ev=>canvas.addEventListener(ev, e=>e.preventDefault(), {passive:false}));

  function render(){
    const aspect = canvas.width / canvas.height;
    const proj = mat4Perspective(fov, aspect, 0.01, 10.0);          // FOV fijo
    let view = mat4Identity();
    // c√°mara en esfera, radio fijo (NO ZOOM)
    const cam = [ radius*Math.sin(rotY)*Math.cos(rotX),
                  radius*Math.sin(rotX),
                  radius*Math.cos(rotY)*Math.cos(rotX) ];
    view = mat4Translate(view, [-cam[0], -cam[1], -cam[2]]);
    const model = mat4Identity();

    const mvp = mat4Multiply(proj, view);
    gl.clearColor(1,1,1,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT); gl.enable(gl.DEPTH_TEST);
    gl.uniformMatrix4fv(uMVP,false,new Float32Array(mvp));
    gl.uniformMatrix4fv(uModel,false,new Float32Array(model));
    gl.uniform3fv(uCam,new Float32Array(cam));
    gl.uniform3fv(uColor,new Float32Array([0.22,0.24,0.28]));
    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    requestAnimationFrame(render);
  }
  render();

  return { setAngles:(x,y)=>{rotX=x; rotY=y;} };
}

// ‚ÄúFoto‚Äù (canvas superior): render fijo sin gestos
const hero = startViewer(document.getElementById('hero'), false);
if(hero){ hero.setAngles(0.5, 0.8); }

// Visor interactivo: solo rotaci√≥n, sin zoom/pan
let viewer = null;
const wrap = document.getElementById('viewerWrap');
document.getElementById('toggle').addEventListener('click', ()=>{
  const open = wrap.style.display==='block';
  wrap.style.display = open ? 'none':'block';
  if(!open && !viewer){
    viewer = startViewer(document.getElementById('viewer'), true);
  }
  if(!open) wrap.scrollIntoView({behavior:'smooth'});
});
</script>
</body>
</html>
